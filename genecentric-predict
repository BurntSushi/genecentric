#!/usr/bin/env python2
'''
'genecentric-predict' is a script that cuts out T% of the edges from the source
data, and makes a negative weight prediction on those cut out edges based
on the number of times each of the endpoints are in opposite partitions.
'''

import csv
import random

import geneids # personal library to convert locus -> product name

import bpm.cmdargs.predict # Which command line arguments do we want?
from bpm import conf, geneinter, parallel, partition, predict, prune

# parallel.print_progress() 

geneinter.load_genes() # Creates global vars geneinter.genes and geneinter.gis

negative = positive = zero = 0
tnegative = tpositive = tzero = 0

# Now cut out the test set from geneinter.gis and add it to geneinter.gistest
geneinter.test = {} # gene pair -> float
for g1, g2 in geneinter.unique_pairs:
    if random.random() <= conf.T:
        geneinter.test[(g1, g2)] = geneinter.gis[(g1, g2)]
        geneinter.gis[(g1, g2)] = 0.0
        geneinter.gis[(g2, g1)] = 0.0

# Calculate the total number of steps so we can measure progress
parallel.steps = conf.M + geneinter.genecount() + sum(parallel.costs.values())

# Create a BPM from every gene and then prune them
parts = partition.bpms()
bpms = prune.prune(parts)
predictions = predict.bpm_prediction(bpms)

outf = open(conf.predict, 'w+')
out = csv.writer(outf, delimiter='\t')
out.writerow(['Prediction', 'Gene 1', 'Gene 2',
              '# Opp', '# Same', '# NIL', 'Real weight'])
for g1, g2, opp, same, nil, real in predictions:
    ng1 = geneids.locus_to_product(g1)
    ng2 = geneids.locus_to_product(g2)
    if opp > same:
        predStr = 'NEGATIVE'
    elif same > opp:
        predStr = 'POSITIVE'
    else:
        predStr = 'UNDECIDED'
    out.writerow([predStr, ng1, ng2, opp, same, nil, real])

parallel.print_progress(final=True)

